[
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "PyPDF2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "PyPDF2",
        "description": "PyPDF2",
        "detail": "PyPDF2",
        "documentation": {}
    },
    {
        "label": "PdfWriter",
        "importPath": "PyPDF2",
        "description": "PyPDF2",
        "isExtraImport": true,
        "detail": "PyPDF2",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "urllib.request",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.request",
        "description": "urllib.request",
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "urllib.error",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.error",
        "description": "urllib.error",
        "detail": "urllib.error",
        "documentation": {}
    },
    {
        "label": "HTTPError",
        "importPath": "urllib.error",
        "description": "urllib.error",
        "isExtraImport": true,
        "detail": "urllib.error",
        "documentation": {}
    },
    {
        "label": "socket",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "socket",
        "description": "socket",
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "ssl",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ssl",
        "description": "ssl",
        "detail": "ssl",
        "documentation": {}
    },
    {
        "label": "urlparse",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "ThreadPoolExecutor",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "as_completed",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "download_pdf",
        "importPath": "scripts.download_files",
        "description": "scripts.download_files",
        "isExtraImport": true,
        "detail": "scripts.download_files",
        "documentation": {}
    },
    {
        "label": "download_task",
        "importPath": "scripts.download_files",
        "description": "scripts.download_files",
        "isExtraImport": true,
        "detail": "scripts.download_files",
        "documentation": {}
    },
    {
        "label": "download_task",
        "importPath": "scripts.download_files",
        "description": "scripts.download_files",
        "isExtraImport": true,
        "detail": "scripts.download_files",
        "documentation": {}
    },
    {
        "label": "return_df",
        "importPath": "scripts.download_files",
        "description": "scripts.download_files",
        "isExtraImport": true,
        "detail": "scripts.download_files",
        "documentation": {}
    },
    {
        "label": "is_valid_pdf",
        "importPath": "scripts.download_files",
        "description": "scripts.download_files",
        "isExtraImport": true,
        "detail": "scripts.download_files",
        "documentation": {}
    },
    {
        "label": "create_corrupt_pdf",
        "importPath": "tests.utils.utils",
        "description": "tests.utils.utils",
        "isExtraImport": true,
        "detail": "tests.utils.utils",
        "documentation": {}
    },
    {
        "label": "create_pdf_file",
        "importPath": "tests.utils.utils",
        "description": "tests.utils.utils",
        "isExtraImport": true,
        "detail": "tests.utils.utils",
        "documentation": {}
    },
    {
        "label": "delete_folder",
        "importPath": "tests.utils.utils",
        "description": "tests.utils.utils",
        "isExtraImport": true,
        "detail": "tests.utils.utils",
        "documentation": {}
    },
    {
        "label": "is_valid_pdf",
        "kind": 2,
        "importPath": "scripts.download_files",
        "description": "scripts.download_files",
        "peekOfCode": "def is_valid_pdf(file_path):\n    \"\"\"Checks if a PDF file is valid by attempting to read its pages.\"\"\"\n    try:\n        with open(file_path, \"rb\") as pdf_file:\n            pdf_reader = PyPDF2.PdfReader(pdf_file)\n            return len(pdf_reader.pages) > 0  # Valid if it has pages\n    except (PyPDF2.errors.PdfReadError, Exception):\n        return False  # Invalid PDF file\n# -------------------- DOWNLOAD FUNCTION --------------------\ndef download_pdf(url, save_path, retries=3, timeout=10):",
        "detail": "scripts.download_files",
        "documentation": {}
    },
    {
        "label": "download_pdf",
        "kind": 2,
        "importPath": "scripts.download_files",
        "description": "scripts.download_files",
        "peekOfCode": "def download_pdf(url, save_path, retries=3, timeout=10):\n    \"\"\"\n    Attempts to download a PDF file with multiple retries in case of failures.\n    - url: PDF download link\n    - save_path: Local path to save the PDF\n    - retries: Number of retry attempts\n    - timeout: Time limit per download attempt\n    \"\"\"\n    if not url:  # Skip if the URL is missing\n        return \"No URL provided\"",
        "detail": "scripts.download_files",
        "documentation": {}
    },
    {
        "label": "download_task",
        "kind": 2,
        "importPath": "scripts.download_files",
        "description": "scripts.download_files",
        "peekOfCode": "def download_task(j, df, dwn_pth=dwn_path):\n    # Ensure the output directory exists\n    dwn_pth.mkdir(parents=True, exist_ok=True)\n    \"\"\"\n    Attempts to download a PDF for a given row index (BRnum).\n    - Tries the primary URL first\n    - If it fails, attempts an alternative URL if available\n    - Returns download status\n    \"\"\"\n    url1 = str(df.at[j, 'Pdf_URL']) if pd.notna(df.at[j, 'Pdf_URL']) else None",
        "detail": "scripts.download_files",
        "documentation": {}
    },
    {
        "label": "execute_parallel_downloads",
        "kind": 2,
        "importPath": "scripts.download_files",
        "description": "scripts.download_files",
        "peekOfCode": "def execute_parallel_downloads():\n    \"\"\"\n    Executes parallel downloads using ThreadPoolExecutor.\n    Updates the DataFrame with the download status.\n    \"\"\"\n    # Define the column used as the unique ID in the Excel file\n    id = \"BRnum\"\n    df = return_df(id)\n    num_threads = 5  # Adjust based on system capabilities\n    with ThreadPoolExecutor(max_workers=num_threads) as executor:",
        "detail": "scripts.download_files",
        "documentation": {}
    },
    {
        "label": "return_df",
        "kind": 2,
        "importPath": "scripts.download_files",
        "description": "scripts.download_files",
        "peekOfCode": "def return_df(id, dwn_pth=dwn_path):\n    \"\"\"\n    Returns the DataFrame containing the URLs to download.\n    Excludes already downloaded files and limits the number of downloads.\n    \"\"\"\n    # Get already downloaded files (to avoid unnecessary re-downloads)\n    existing_files = {Path(f).stem for f in glob.glob(f\"{dwn_pth}/*.pdf\")}\n    # -------------------- LOAD INPUT DATA --------------------\n    # Load the Excel file containing PDF URLs\n    df = pd.read_excel(list_pth, sheet_name=0, index_col=id)",
        "detail": "scripts.download_files",
        "documentation": {}
    },
    {
        "label": "ssl._create_default_https_context",
        "kind": 5,
        "importPath": "scripts.download_files",
        "description": "scripts.download_files",
        "peekOfCode": "ssl._create_default_https_context = ssl._create_unverified_context\n# -------------------- PATH CONFIGURATION --------------------\n# Define project root path (assumes script is inside a subdirectory of the project)\nproject_root = Path(__file__).resolve().parent.parent\ndwn_path = project_root / \"output\" / \"downloads\"\n# Define file paths\nlist_pth = project_root / \"data\" / \\\n    \"GRI_2017_2020 (1).xlsx\"  # Excel file containing URLs\nmetadata_pth = project_root / \"data\" / \"Metadata2017_2020.xlsx\"  # Metadata file\n# -------------------- PDF VALIDATION FUNCTION --------------------",
        "detail": "scripts.download_files",
        "documentation": {}
    },
    {
        "label": "project_root",
        "kind": 5,
        "importPath": "scripts.download_files",
        "description": "scripts.download_files",
        "peekOfCode": "project_root = Path(__file__).resolve().parent.parent\ndwn_path = project_root / \"output\" / \"downloads\"\n# Define file paths\nlist_pth = project_root / \"data\" / \\\n    \"GRI_2017_2020 (1).xlsx\"  # Excel file containing URLs\nmetadata_pth = project_root / \"data\" / \"Metadata2017_2020.xlsx\"  # Metadata file\n# -------------------- PDF VALIDATION FUNCTION --------------------\ndef is_valid_pdf(file_path):\n    \"\"\"Checks if a PDF file is valid by attempting to read its pages.\"\"\"\n    try:",
        "detail": "scripts.download_files",
        "documentation": {}
    },
    {
        "label": "dwn_path",
        "kind": 5,
        "importPath": "scripts.download_files",
        "description": "scripts.download_files",
        "peekOfCode": "dwn_path = project_root / \"output\" / \"downloads\"\n# Define file paths\nlist_pth = project_root / \"data\" / \\\n    \"GRI_2017_2020 (1).xlsx\"  # Excel file containing URLs\nmetadata_pth = project_root / \"data\" / \"Metadata2017_2020.xlsx\"  # Metadata file\n# -------------------- PDF VALIDATION FUNCTION --------------------\ndef is_valid_pdf(file_path):\n    \"\"\"Checks if a PDF file is valid by attempting to read its pages.\"\"\"\n    try:\n        with open(file_path, \"rb\") as pdf_file:",
        "detail": "scripts.download_files",
        "documentation": {}
    },
    {
        "label": "list_pth",
        "kind": 5,
        "importPath": "scripts.download_files",
        "description": "scripts.download_files",
        "peekOfCode": "list_pth = project_root / \"data\" / \\\n    \"GRI_2017_2020 (1).xlsx\"  # Excel file containing URLs\nmetadata_pth = project_root / \"data\" / \"Metadata2017_2020.xlsx\"  # Metadata file\n# -------------------- PDF VALIDATION FUNCTION --------------------\ndef is_valid_pdf(file_path):\n    \"\"\"Checks if a PDF file is valid by attempting to read its pages.\"\"\"\n    try:\n        with open(file_path, \"rb\") as pdf_file:\n            pdf_reader = PyPDF2.PdfReader(pdf_file)\n            return len(pdf_reader.pages) > 0  # Valid if it has pages",
        "detail": "scripts.download_files",
        "documentation": {}
    },
    {
        "label": "metadata_pth",
        "kind": 5,
        "importPath": "scripts.download_files",
        "description": "scripts.download_files",
        "peekOfCode": "metadata_pth = project_root / \"data\" / \"Metadata2017_2020.xlsx\"  # Metadata file\n# -------------------- PDF VALIDATION FUNCTION --------------------\ndef is_valid_pdf(file_path):\n    \"\"\"Checks if a PDF file is valid by attempting to read its pages.\"\"\"\n    try:\n        with open(file_path, \"rb\") as pdf_file:\n            pdf_reader = PyPDF2.PdfReader(pdf_file)\n            return len(pdf_reader.pages) > 0  # Valid if it has pages\n    except (PyPDF2.errors.PdfReadError, Exception):\n        return False  # Invalid PDF file",
        "detail": "scripts.download_files",
        "documentation": {}
    },
    {
        "label": "create_corrupt_pdf",
        "kind": 2,
        "importPath": "tests.utils.utils",
        "description": "tests.utils.utils",
        "peekOfCode": "def create_corrupt_pdf(save_path):\n    try:\n        os.makedirs(os.path.dirname(save_path), exist_ok=True)\n        with open(save_path, \"wb\") as f:\n            f.write(b\"This is not valid PDF content\")\n        return True\n    except Exception as e:\n        return False\ndef create_pdf_file(save_path):\n    try:",
        "detail": "tests.utils.utils",
        "documentation": {}
    },
    {
        "label": "create_pdf_file",
        "kind": 2,
        "importPath": "tests.utils.utils",
        "description": "tests.utils.utils",
        "peekOfCode": "def create_pdf_file(save_path):\n    try:\n        os.makedirs(os.path.dirname(save_path), exist_ok=True)\n        writer = PdfWriter()\n        writer.add_blank_page(width=72 * 8.5, height=72 * 11)\n        with open(save_path, \"wb\") as f:\n            writer.write(f)\n        return True\n    except Exception as e:\n        return False",
        "detail": "tests.utils.utils",
        "documentation": {}
    },
    {
        "label": "delete_folder",
        "kind": 2,
        "importPath": "tests.utils.utils",
        "description": "tests.utils.utils",
        "peekOfCode": "def delete_folder(folder_path):\n    try:\n        if os.path.exists(folder_path):\n            shutil.rmtree(folder_path)\n        return True\n    except Exception as e:\n        return False",
        "detail": "tests.utils.utils",
        "documentation": {}
    },
    {
        "label": "TestDownloadPDF",
        "kind": 6,
        "importPath": "tests.test_download_pdf",
        "description": "tests.test_download_pdf",
        "peekOfCode": "class TestDownloadPDF(unittest.TestCase):\n    def setUp(self) -> None:\n        # Patch shared dependencies\n        self.patcher_urlopen = patch(\"urllib.request.urlopen\")\n        self.patcher_copyfileobj = patch(\"shutil.copyfileobj\")\n        self.patcher_open = patch(\"builtins.open\", new_callable=MagicMock)\n        self.patcher_is_valid_pdf = patch(\"scripts.download_files.is_valid_pdf\")\n        # Start patches\n        self.mock_urlopen = self.patcher_urlopen.start()\n        self.mock_copyfileobj = self.patcher_copyfileobj.start()",
        "detail": "tests.test_download_pdf",
        "documentation": {}
    },
    {
        "label": "TestDownloadTask",
        "kind": 6,
        "importPath": "tests.test_download_task",
        "description": "tests.test_download_task",
        "peekOfCode": "class TestDownloadTask(unittest.TestCase):\n    def setUp(self):\n        # Patch shared dependencies\n        self.patcher_download_pdf = patch(\"scripts.download_files.download_pdf\")\n        self.patcher_copy = patch(\"scripts.download_files.shutil.copy\")\n        # Start patches\n        self.mock_download_pdf = self.patcher_download_pdf.start()\n        self.mock_copy = self.patcher_copy.start()\n    def tearDown(self):\n        # Stop all patches",
        "detail": "tests.test_download_task",
        "documentation": {}
    },
    {
        "label": "TestDownloadTaskIntegration",
        "kind": 6,
        "importPath": "tests.test_download_task_integration",
        "description": "tests.test_download_task_integration",
        "peekOfCode": "class TestDownloadTaskIntegration(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Set up the test environment and initialize the dataframe.\"\"\"\n        self.id = \"BRnum\"\n        self.df = return_df(self.id)\n        os.makedirs(test_output_dir, exist_ok=True)\n        self.output_path = test_output_dir\n        self.pdf_path = test_output_dir / \"BR50041.pdf\"\n    def tearDown(self):\n        \"\"\"Clean up any residual files or directories after each test.\"\"\"",
        "detail": "tests.test_download_task_integration",
        "documentation": {}
    },
    {
        "label": "project_root",
        "kind": 5,
        "importPath": "tests.test_download_task_integration",
        "description": "tests.test_download_task_integration",
        "peekOfCode": "project_root = Path(__file__).resolve().parent.parent\ntest_output_dir = project_root / \"tests\" / \"test_output\"\nclass TestDownloadTaskIntegration(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Set up the test environment and initialize the dataframe.\"\"\"\n        self.id = \"BRnum\"\n        self.df = return_df(self.id)\n        os.makedirs(test_output_dir, exist_ok=True)\n        self.output_path = test_output_dir\n        self.pdf_path = test_output_dir / \"BR50041.pdf\"",
        "detail": "tests.test_download_task_integration",
        "documentation": {}
    },
    {
        "label": "test_output_dir",
        "kind": 5,
        "importPath": "tests.test_download_task_integration",
        "description": "tests.test_download_task_integration",
        "peekOfCode": "test_output_dir = project_root / \"tests\" / \"test_output\"\nclass TestDownloadTaskIntegration(unittest.TestCase):\n    def setUp(self):\n        \"\"\"Set up the test environment and initialize the dataframe.\"\"\"\n        self.id = \"BRnum\"\n        self.df = return_df(self.id)\n        os.makedirs(test_output_dir, exist_ok=True)\n        self.output_path = test_output_dir\n        self.pdf_path = test_output_dir / \"BR50041.pdf\"\n    def tearDown(self):",
        "detail": "tests.test_download_task_integration",
        "documentation": {}
    },
    {
        "label": "TestIsValidPDF",
        "kind": 6,
        "importPath": "tests.test_is_valid_pdf",
        "description": "tests.test_is_valid_pdf",
        "peekOfCode": "class TestIsValidPDF(unittest.TestCase):\n    \"\"\"This test suite will use Arrange, Act, Assert (AAA) pattern.\"\"\"\n    def setUp(self) -> None:\n        \"\"\"Set up test environment.\"\"\"\n        os.makedirs(path, exist_ok=True)\n    def tearDown(self) -> None:\n        \"\"\"Clean up test environment.\"\"\"\n        delete_folder(path)\n    def test_is_valid_pdf_valid(self) -> None:\n        # Arrange",
        "detail": "tests.test_is_valid_pdf",
        "documentation": {}
    },
    {
        "label": "path",
        "kind": 5,
        "importPath": "tests.test_is_valid_pdf",
        "description": "tests.test_is_valid_pdf",
        "peekOfCode": "path = \"tests/test_files\"\nclass TestIsValidPDF(unittest.TestCase):\n    \"\"\"This test suite will use Arrange, Act, Assert (AAA) pattern.\"\"\"\n    def setUp(self) -> None:\n        \"\"\"Set up test environment.\"\"\"\n        os.makedirs(path, exist_ok=True)\n    def tearDown(self) -> None:\n        \"\"\"Clean up test environment.\"\"\"\n        delete_folder(path)\n    def test_is_valid_pdf_valid(self) -> None:",
        "detail": "tests.test_is_valid_pdf",
        "documentation": {}
    }
]